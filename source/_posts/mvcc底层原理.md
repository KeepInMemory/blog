---
title: mvcc底层原理
date: 2020-08-14 14:50:17
tags:
  - MySQL
---

MVCC主要为了提高并发的读写性能，不用加锁就能让多个事务并发读写

<!--more-->

下面的每个Transaction的序号是从小到大生成的，现在有三个事务，小于100的事务全部已经提交，100-300为未提交事务一直到已创建的最大事务，300以上还没创建所以是未开始事务

min_id=100,max_id=300

read-view:[100,200],300

![2](mvcc底层原理\2.png)

![1](mvcc底层原理/1.png)

事务100执行set c1 = '123'会生成一个新记录，让旧记录放在undo回滚日志里，按时间顺序新记录和旧记录形成版本链，蓝色为当前最新的记录

![3](mvcc底层原理/3.png)

使用上面的read-view[100,200],300得到name查询结果

查询过程为Select快照读去读取版本链，拿每个版本的事务id和read-view去比较

trx_id<100的为已提交事务，是结果可见的

100<=trx_id<=300分为两种情况：一是trx_id在未提交数组中，则事务未提交，仅那个修改的事务可见，其他不可见。二是不在数组中，则事务已提交，结果可见

trx_id>300表示这个版本是生成了raed-view后未来生成的版本，自己是不可见的

**在RC隔离级别下，是每个SELECT都会获取最新的read view；而在RR隔离级别下，则是当事务中的第一个SELECT请求才创建read view。**

这里是在RR隔离级别下

**session1在select的时候就生成了一份read-view，之后就不变了，因为要保证可重复读，然后根据这个read-view查询当前版本链（版本链只有一份，是会随时间变化的）**

**图中session1的三次查询都为lilei300，因为要保证可重复读**



![4](mvcc底层原理/4.png)

**session2在select的时候生成一份read-view[200],300，因为100是<200的且已提交，300是从200一直到最大已创建事务，所以commit了也算进去**

**根据这个read-view查，从上到下，因为200在未提交数组中，所以结果不可见，一直到100，100<最小值200，所以结果可见，结果为lilei2**

