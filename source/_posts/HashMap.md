---
title: HashMap
date: 2020-06-29 09:19:17
tags:
  - 面经
---

### HashMap

#### 什么是HashMap

HashMap是基于哈希表的Map接口实现，它是以key-value存储形式存在，用来放键值对

它的特点是，1.存取是无序的 2.键值都可以为null，但是键最多只能有一个null

JDK1.8之前是由数组+链表组成的，数组是HashMap的主体，用数组是为了方便索引查询，链表则是为了解决哈希冲突。HashMap的默认初始长度是16，采用头插法

JDK1.8以前有两个缺点，一是线程不安全的，Rehash时可能会产生死锁。二是在哈希碰撞多了以后，哈希桶会退化成链表，查询效率也从O(1)变为O(n)

JDK1.8为了解决Rehash时可能会产生死锁的问题采用了尾插法

JDK1.8之后为了解决哈希碰撞严重后退化成链表的问题，数据结构改为了数组+链表+红黑树的形式，当链表长度大于阈值8并且当前数组的长度大于64时，此时该哈希桶上的所有数据改为红黑树存储，如果链表长度大于8但是数组长度小于64不会改成红黑树，而是进行数组扩容。这是因为数组较小，搜索时间相对较短，红黑树需要进行左旋右旋变色等操作来保持平衡，改成红黑树反而会降低效率。当哈希桶元素数量降到6就退化成为链表。

JDK1.8虽然解决了Rehash时死锁的问题，但还是会存在其他多线程不安全的问题，并发环境下使用ConcurrentHashMap

<!--more-->

#### 为什么数组大小一定是2的幂

Hash值范围大概是40亿个数，不可能创建一个40亿长度的数组，内存就爆了，所以计算后的hash值是不能拿来直接用的，还需要进行计算索引值，一般是进行取模操作，源码中在计算出hash值之后有个indexFor方法计算索引值，计算方法是hash&(length-1)，如果是2的n次方，即10000...后面全是0，减一后会变成01111..后面全是1，此时跟哈希值按位与的话能让数据分配均匀，减少碰撞。如果不是2的幂，那么某些位会成为0，此时hash值和0与怎么样都是0，结果是有些Hash桶永远是空的。

数组长度-1正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。

确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。

如果传入的数字不是2的n次幂，比如10，Hash Map会计算出大于这个数的最接近这个数的2的n次幂，为16

#### 什么是红黑树

红黑树是一个二叉平衡树，二叉树的平均查找时间是O(logn)，如果不巧可能会成为一条线，退化成链表。所以红黑树通过旋转等的操作，保证自己是平衡的。

#### 红黑树原则

1.构成树的结点拥有一个颜色属性，要么是黑要么是红

2.根节点必须是黑色的，叶子节点必须是黑色的

3.从叶节点到根节点的路径上，每条路径黑色节点一定是一致的

4.不能有两个红色节点相连

#### 为什么负载因子是0.75

是空间和时间的一个折中，负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低。

#### 为什么树化的阈值是8

源码的注释里说，理想情况下随机hashCode算法下哈希桶中节点的个数服从参数为0.5的泊松分布，一个桶里面有大于8个元素的概率是小于十万分之一的，因为超过8的概率已经非常小了，所以采用8作为阈值。 

#### Node的hash值计算方法

Node.hash不是key对象的hashcode()返回值，而是key.hashCode返回值高16位异或低16位，作用是优化hash算法，因为这样就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，就很难受。

key.hashCode返回值高16位异或低16位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。

#### put操作

计算索引的算法是先经过key.hashCode()经过高低位异或之后，再按位与table.length-1，得到一个下标

根据槽内状态分为四种

一是slot==null，把put方法传进来的key,value包装成一个node对象，放到slot里

二是slot!=null，node没有链化。先对比node.key与put传入的key是否完全相等，相等就直接替换，用传入的value替换node.value，不相等就是哈希冲突，在slot的node后插入

三是slot!=null，node已经链化。迭代查找node.key与put传入的key是否完全相等，相等就直接替换，用传入的value替换node.value，不相等就是哈希冲突，在slot尾部的node后插入。插入后检查当前链表长度有没有达到树化阈值，如果达到阈值就在put中完成树化

四是slot!-null，node已经树化。TreeNode继承了Node结构，增加了指向父节点的parent、指向左孩子的left、右孩子的right和颜色属性。红黑树的插入首先是找到插入的父节点，找父节点和二叉排序树是一样的，二叉排序树左孩子小于当前节点，右孩子大于当前节点。插入有两种情况，一是一直向下探测，直到叶子节点，将叶子节点作为父节点在左或者右插入，插入后有可能会打破平衡，有个平衡算法进行调整。二是向下探测过程中发现node.key和传入的key相同，进行一次替换操作。

#### 散列表扩容

resize()扩容方法，只有在两种情况下会被调用：

HashMap实行了懒加载: 新建HashMap时不会对Node[] table进行赋值, 而是到第一次插入时, 进行resize时构建Node[] table，Node对象内部有hash、next、key、value字段

当HashMap的大小值大于 threshold16*0.75=12时, 会进行扩容，扩容成2倍。

#### Rehash操作

根据槽内状态分为四种

一是slot==null，不用进行迁移

二是slot!=null，node没有链化。如果node.next为null，根据新表的table.length计算出下标，直接进行迁移

三是slot!=null，node已经链化。如果node.next不为null，说明发生过hash冲突，将slot里的链表拆成高位链和低位链。因为老表的链表中这些node的hash值低位全是相同的，但是高位有0有1，于是将原先的链表分成了两部分

四是slot!-null，node已经树化。TreeNode对象仍然保留着next字段，这个slot的拆分也是根据分为高位链和低位链，但是拆分完成后需要看两个链的长度，如果长度<=6退化成一个普通的node链表，如果长度>6继续维持红黑树结构